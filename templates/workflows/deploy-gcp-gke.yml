# Google Kubernetes Engine (GKE) Deployment
# Deploys applications to a GKE cluster using Kubernetes manifests.
#
# Prerequisites:
# 1. Create GKE cluster
# 2. Create Artifact Registry repository
# 3. Set up Workload Identity Federation (OIDC)
# 4. Create Kubernetes manifests or Helm charts
#
# Required secrets:
#   GCP_PROJECT_ID         - Google Cloud project ID
#   GCP_WORKLOAD_IDENTITY_PROVIDER - Workload Identity Provider
#   GCP_SERVICE_ACCOUNT    - Service account email
#
# Required variables:
#   GCP_REGION             - GKE cluster region
#   GKE_CLUSTER            - GKE cluster name
#   GKE_NAMESPACE          - Kubernetes namespace
#
# Documentation:
# - https://cloud.google.com/kubernetes-engine/docs
# - https://github.com/google-github-actions/get-gke-credentials

name: Deploy to Google Kubernetes Engine

on:
  push:
    branches:
      - main
  release:
    types: [published]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GCP_REGION: ${{ vars.GCP_REGION || 'us-central1' }}
  GKE_CLUSTER: ${{ vars.GKE_CLUSTER || 'my-cluster' }}
  GKE_NAMESPACE: ${{ vars.GKE_NAMESPACE || 'default' }}
  # Artifact Registry
  GAR_LOCATION: ${{ vars.GCP_REGION || 'us-central1' }}
  GAR_REPOSITORY: docker-repo
  IMAGE_NAME: ${{ github.repository }}
  # Deployment
  DEPLOYMENT_NAME: my-app

jobs:
  build:
    name: Build and Push
    runs-on: ubuntu-latest
    outputs:
      image: ${{ steps.tag.outputs.image }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Configure Docker for Artifact Registry
        run: |
          gcloud auth configure-docker ${{ env.GAR_LOCATION }}-docker.pkg.dev --quiet

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Generate image tag
        id: tag
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          IMAGE="${{ env.GAR_LOCATION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.GAR_REPOSITORY }}/${{ env.DEPLOYMENT_NAME }}"
          echo "image=${IMAGE}:${SHORT_SHA}" >> $GITHUB_OUTPUT

      - name: Build and push
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ steps.tag.outputs.image }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    name: Deploy to GKE
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: production

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - name: Get GKE credentials
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: ${{ env.GKE_CLUSTER }}
          location: ${{ env.GCP_REGION }}

      # Option 1: Deploy using Kustomize
      - name: Deploy with Kustomize
        run: |
          # Set the new image
          cd k8s/overlays/production
          kustomize edit set image app=${{ needs.build.outputs.image }}

          # Apply the manifests
          kubectl apply -k .

          # Wait for rollout
          kubectl rollout status deployment/${{ env.DEPLOYMENT_NAME }} \
            -n ${{ env.GKE_NAMESPACE }} \
            --timeout=300s

      # Option 2: Deploy using Helm (Alternative)
      # - name: Deploy with Helm
      #   run: |
      #     helm upgrade --install ${{ env.DEPLOYMENT_NAME }} ./charts/app \
      #       --namespace ${{ env.GKE_NAMESPACE }} \
      #       --create-namespace \
      #       --set image.repository=${{ env.GAR_LOCATION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.GAR_REPOSITORY }}/${{ env.DEPLOYMENT_NAME }} \
      #       --set image.tag=${{ github.sha }} \
      #       --wait \
      #       --timeout 5m

      # Option 3: Simple kubectl (Alternative)
      # - name: Deploy with kubectl
      #   run: |
      #     kubectl set image deployment/${{ env.DEPLOYMENT_NAME }} \
      #       app=${{ needs.build.outputs.image }} \
      #       -n ${{ env.GKE_NAMESPACE }}
      #
      #     kubectl rollout status deployment/${{ env.DEPLOYMENT_NAME }} \
      #       -n ${{ env.GKE_NAMESPACE }} \
      #       --timeout=300s

      - name: Get service URL
        id: url
        run: |
          SERVICE_IP=$(kubectl get service ${{ env.DEPLOYMENT_NAME }} \
            -n ${{ env.GKE_NAMESPACE }} \
            -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "pending")
          echo "url=http://${SERVICE_IP}" >> $GITHUB_OUTPUT

      - name: Summary
        run: |
          echo "## GKE Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Cluster:** ${{ env.GKE_CLUSTER }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Namespace:** ${{ env.GKE_NAMESPACE }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployment:** ${{ env.DEPLOYMENT_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image:** ${{ needs.build.outputs.image }}" >> $GITHUB_STEP_SUMMARY
